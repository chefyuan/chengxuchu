---
lang: zh-CN
title: 1、基础知识
description: 很细。
---




<p id="基础知识"></p>

# 1.基础知识

<p id="interrupt"></p>


## 1.0 interrupt()

该函数代表的是，中断状态，当某个线程被其他线程执行interrupt()时，则会给线程一个通知，并将线程的状态变为中断，有人希望你中断啦，怎么做就是你的事啦。是否释放锁由我们自己决定，我们可以通过函数 isinterrupt() 来获得中断状态，

<p id="r和c不同"></p>

## 1.1 runnable和 callable 有什么不同？

两者都是调用接口，都需要使用start方法启动。

*   callable的核心是`call()`方法，允许返回值，`runnable`的核心是`run()`方法，没有返回值
*   `call()`方法可以抛出异常，但是`run()`方法不行
*   `callable`和`runnable`都可以应用于`executors`，`thread`类只支持`runnable`

<p id="r和s不同"></p>

## 1.2 线程的 run 和 start 有什么区别？

我们创建好线程对象之后，调用run方法，仅仅是调用某个方法，不会创建线程，但是start会开一个新的线程。

另外start只可以启动一次，而run可以启动多次。

<p id="为什么用start开启线程"></p>

## 1.3 为什么调用 start 而不是 run?

`start()`方法来启动线程，真正实现了多线程运行，这时无需等待`run()`方法体代码执行完毕而直接继续执行下面的代码。通过调用Thread类的 `start()`方法来启动一个线程，`这时此线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行run()方法`，这里方法`run()`称为线程体，它包含了要执行的这个线程的内容，`run()`方法运行结束，此线程随即终止。

`run()`方法只是类的一个普通方法而已，如果直接调用`run`方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待`run()`方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。

调用`start()`方法可以开启一个线程，而`run()`方法只是thread类中的一个普通方法，直接调用`run()`方法还是在主线程中执行的。
