---
lang: zh-CN
title: 4、网安相关
description: 很细。
---



# 4.网络安全篇

<p id="XSS"></p>

## 4.0 什么是XSS攻击

它指的是恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意攻击用户的特殊目的。

XSS的攻击方式就是想办法“教唆”用户的浏览器去执行一些这个网页中原本不存在的前端代码。

其实我们常用的留言板就可以产生XSS攻击，我们知道留言板通常的任务就是把用户留言的内容展示出来。

正常情况下，用户的留言都是正常的语言文字，留言板显示的内容也就没毛病。然而这个时候如果有人不按套路出牌，在留言内容中丢进去一行

```html
<script>alert(“这是一个攻击”)</script>
```


那么留言板界面的网页代码就会变成形如以下：

那么这个时候问题就来了，当浏览器解析到用户输入的代码那一行时会发生什么呢？答案很显然，浏览器并不知道这些代码改变了原本程序的意图，会照做弹出一个信息框。就像这样

```html
<html>
    <head>
       <title>留言板</title>
    </head>
<body>
<div id=”board” 
        <script>alert(“这是一个攻击”)</script>
</div>     
    </body>
</html>

```

<p id="解决XSS"></p>

## 4.1 如何解决xss攻击

1.不相信用户输入

2.限制输长度

3.html转义等

4.对跳转型链接进行特殊对待

推荐阅读：https://zhuanlan.zhihu.com/p/26177815

<p id="半连接SYN"></p>


## 4.2 半连接队列和 SYN Flood 攻击的关系

TCP进入三次握手前，服务端会从**CLOSED** 状态变为**LISTEN** 状态,同时在内部创建了两个队列：半连接队列（SYN队列）和全连接队列（ACCEPT队列）。

什么是**半连接队列（SYN队列）**  呢? 什么是**全连接队列（ACCEPT队列）**  呢？回忆下TCP三次握手的图：

![三次握手](https://chengxuchu-1301103198.cos.ap-beijing.myqcloud.com/Photo/202304210848916.png)

- TCP三次握手时，客户端发送SYN到服务端，服务端收到之后，便回复**ACK和SYN** ，状态由**LISTEN变为SYN_RCVD** ，此时这个连接就被推入了**SYN队列** ，即半连接队列。

- 当客户端回复ACK, 服务端接收后，三次握手就完成了。这时连接会等待被具体的应用取走，在被取走之前，它被推入ACCEPT队列，即全连接队列。

SYN Flood是一种典型的DoS (Denial of Service，拒绝服务) 攻击，它在短时间内，伪造**不存在的IP地址** ,向服务器大量发起SYN报文。当服务器回复SYN+ACK报文后，不会收到ACK回应报文，导致服务器上建立大量的半连接半连接队列满了，这就无法处理正常的TCP请求啦。

主要有 **syn cookie** 和**SYN Proxy防火墙** 等方案应对。

- **syn cookie** ：在收到SYN包后，服务器根据一定的方法，以数据包的源地址、端口等信息为参数计算出一个cookie值作为自己的SYNACK包的序列号，回复SYN+ACK后，服务器并不立即分配资源进行处理，等收到发送方的ACK包后，重新根据数据包的源地址、端口计算该包中的确认序列号是否正确，如果正确则建立连接，否则丢弃该包。  
- **SYN Proxy防火墙** ：服务器防火墙会对收到的每一个SYN报文进行代理和回应，并保持半连接。等发送方将ACK包返回后，再重新构造SYN包发到服务器，建立真正的TCP连接。

推荐阅读：https://blog.csdn.net/qq_41147507/article/details/109600713

<p id="Socket过程"></p>


## 4.3 socket的执行过程

![](https://chengxuchu-1301103198.cos.ap-beijing.myqcloud.com/Photo/202304221622215.png)

在connect位置进行三次握手

IO多路复用发生在accept函数之后

监听的是已经建立好连接准备发送数据的socket

说 TCP 的 Socket 就是一个文件流，是非常准确的。因为，Socket 在 Linux 中就是以文件的形式存在的。

除此之外，还存在文件描述符。写入和读出，也是通过文件描述符。

socket是一个文件，那么就有文件描述符

![image-20211009205159787](https://chengxuchu-1301103198.cos.ap-beijing.myqcloud.com/Photo/202304221622734.png)

该图片来自于《极客时间》

socket对应的文件不是存在磁盘中的，是存在内存中的，方便快速传输。

服务端一般是listen一个端口，然后理论上的最大连接数，则和客户端ip地址的数目和端口号的数目有关，则是 2^32 * 2^16次方。

但是现实中不能够连接那么多，因为socket文件是存储在内存中的，内存限制，而是文件描述符的个数也有所限制。

我们如何建立更多的socket 连接，我们可以通过fork子进程的方式，父进程用来

进程复制过程

![](https://chengxuchu-1301103198.cos.ap-beijing.myqcloud.com/Photo/202304221622064.png)

该图片来自于《极客时间》

通过fork函数创建的子进程和父进程几乎是一模一样的，（文件描述符列表也复制了一份，这样子进程就能通过这个一模一样的文件描述符去操作父进程的已连接socket了。

epoll create

epoll controll：挂到红黑树上时，如何快速放到链表，当我们执行epoll_ctl时，除了把socket放到epoll文件系统里file对象对应的红黑树上之外，还`会给内核中断处理程序注册一个回调函数，告诉内核，如果这个句柄的中断到了，就把它放到准备就绪list链表里。`所以，当一个socket上有数据到了，内核在把网卡上的数据copy到内核中后就来把socket插入到准备就绪链表里了

epoll wait 查看链表

推荐阅读：https://www.zhihu.com/question/29637351
